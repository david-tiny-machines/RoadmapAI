# v0.0.3h Implementation Plan: Capacity Migration & Polish

## Overview
Migrate capacity data storage from local storage to Supabase. Update the `CapacityManager` component to interact with Supabase, ensuring correct date handling, type safety, and validation. Implement real-time sync if feasible and standardize error handling patterns.

## Prerequisites
- Access to the application development environment
- Supabase credentials
- Chrome browser for testing
- Completion of v0.0.3g (Initiative Migration)

## Test Environment
- Browser: Chrome latest version
- Screen size: Desktop viewport (1920x1080)
- Network: Test under normal conditions

## Type Definitions

### Database Types (`types/database.ts`)
```typescript
// Add DbCapacityType interface
export interface DbCapacityType {
  id: string; // Or potentially composite key (user_id, month)
  user_id: string;
  month: string; // Stored as DATE (YYYY-MM-01) in DB
  available_days: number;
  created_at: string;
  updated_at: string;
  // team_id: string | null; // If implementing team structures
}

// Add conversion utilities
export function toDbCapacity(/* capacity: Capacity */): DbCapacityType {
  // Implementation needed: map frontend type to DbCapacityType
  // Ensure month is converted to YYYY-MM-01 format string
  // Ensure available_days is integer
  return {} as DbCapacityType; // Placeholder
}

export function fromDbCapacity(/* dbCapacity: DbCapacityType */): any /* Capacity */ {
  // Implementation needed: map DbCapacityType to frontend type
  // Ensure available_days is treated as number
  // Convert month DATE string (YYYY-MM-DD) back to YYYY-MM for UI state if needed
  return {} as any; // Placeholder - define/use existing Capacity type
}
```

### Frontend Types (`types/capacity.ts`)
```typescript
// Ensure existing CapacityData / MonthlyCapacity types align with DB structure
// (using camelCase) and update if necessary.
// Verification Step: Confirm/finalize the required frontend type interfaces below based on component needs before implementation.
export interface MonthlyCapacity {
  month: string; // YYYY-MM format for UI
  availableDays: number;
}

export interface CapacityData {
  monthlyCapacities: MonthlyCapacity[];
  // userId: string; // Add if needed
  // teamId?: string; // If implementing teams
}
```

## Database Updates

### Migration Script
```sql
-- Create capacity table (e.g., monthly_capacity)
CREATE TABLE IF NOT EXISTS monthly_capacity (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  month DATE NOT NULL, -- Stores YYYY-MM-01
  available_days INTEGER NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  -- team_id UUID NULL REFERENCES teams(id), -- If implementing teams
  CONSTRAINT positive_capacity CHECK (available_days >= 0), -- Allow 0 days
  CONSTRAINT unique_user_month_capacity UNIQUE (user_id, month) -- Ensure one entry per user per month
  -- Design Note: Team-based capacity (team_id) is deferred in this iteration to focus on the core user-specific migration. The unique constraint reflects this focus. Future iterations may require adding team_id and adjusting this constraint.
  -- Add team_id to UNIQUE constraint if implementing teams
);

-- Add Indexes
CREATE INDEX idx_monthly_capacity_user_month ON monthly_capacity(user_id, month);

-- Add Row Level Security (RLS) Policies
ALTER TABLE monthly_capacity ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage their own capacity" ON monthly_capacity
  FOR ALL USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Create trigger for updated_at timestamp
-- Ensure the function 'update_updated_at_column' exists from previous migrations
CREATE TRIGGER update_monthly_capacity_updated_at
  BEFORE UPDATE ON monthly_capacity
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

## Component Updates (`components/capacity/CapacityManager.tsx`)

1.  **Code Review:** Familiarize yourself with the existing logic, state management, and potential side effects within `components/capacity/CapacityManager.tsx` before proceeding with modifications.
2.  **Remove Local Storage:** Delete all logic related to reading/writing `roadmapai_capacity` from local storage.
3.  **Supabase Integration:**
    *   Fetch capacity data from the `monthly_capacity` table on component mount for the logged-in user. Filter by `user_id`.
    *   Use `fromDbCapacity` utility to convert fetched data for use in the component state. Handle the `month` conversion (DB: `YYYY-MM-DD` -> State: `YYYY-MM`).
4.  **Saving Data:**
    *   Modify `handleCapacityChange` or similar function where individual month capacities are updated.
    *   When capacity for a month is updated, perform an `upsert` operation on the `monthly_capacity` table for that specific user and month.
    *   Use `toDbCapacity` utility for conversion before saving. Ensure the `month` is formatted as `YYYY-MM-01` and `available_days` is an integer. Use the `user_id` from the auth context.
5.  **Date Handling:**
    *   Ensure month identification uses the `YYYY-MM` format internally for component state, display, and iteration.
    *   Before saving to Supabase via `upsert`, convert the `YYYY-MM` month string to a `YYYY-MM-01` string using the existing utilities `formatDateToYYYYMMDD` and `fromMonthString` (located in `utils/dateUtils.ts`).
    *   Verify no legacy `toISOString()` issues remain.
6.  **Validation:**
    *   Implement input validation to prevent negative values for `available_days` (allow 0). Use `min="0"` on the input.
    *   Ensure only numeric input is accepted (inherent in `type="number"`, but handle potential parsing issues).
7.  **Real-time Sync (Optional Stretch Goal):**
    *   If time permits, implement a Supabase real-time subscription to update capacity data if it changes elsewhere. Use a channel specific to the user's capacity data.
8.  **Error Handling:**
    *   Implement clear user feedback for loading states and saving errors. Replicate the error handling pattern seen in `InitiativeForm.tsx` (ref: red error box displayed via state, see component around line 170) for consistency.

## Success Criteria
1.  All capacity data successfully stored in Supabase `monthly_capacity` table.
2.  Local storage (`roadmapai_capacity`) cleared and no longer used for capacity.
3.  `CapacityManager` component correctly fetches, displays, and saves data to Supabase.
4.  Date handling uses `YYYY-MM-01` format for database storage and functions correctly without timezone issues.
5.  Input validation prevents invalid capacity values (e.g., negative numbers).
6.  RLS policies ensure users can only access/modify their own capacity data.
7.  Console is clean (no warnings related to capacity management).
8.  (Optional) Real-time updates work correctly if implemented.
9.  Error handling provides clear feedback to the user, consistent with other sections.

## Known Limitations (v0.0.3h)
-   Team-based capacity management not implemented (schema has placeholders).
-   Bulk import/export of capacity data not available.
-   Limited historical tracking/versioning of capacity changes.

## Next Steps
-   Begin Phase 4 (Scenario & Goal Planning).
-   Refine team capacity implementation in a future iteration if required.

## Manual Testing Steps

### 1. Basic Functionality & Data Migration
- **Test 1.1**: First Load After Update - ✅ **PASSED** (Observed known issue: Multiple GoTrueClient instances warning in console)
  - **Action**:
    - Clear `roadmapai_capacity` from local storage (via DevTools or `/dev/storage-debug`).
    - Navigate to the Capacity page.
  - **Expected Result**:
    - Page loads without errors.
    - Default capacity values (or empty state) are shown, fetched from Supabase (likely empty initially).
    - No data is fetched from local storage.
- **Test 1.2**: Data Entry & Persistence - ✅ **PASSED**
  - **Action**:
    - Enter capacity values for several different months (e.g., current month, future month).
    - Set one month to `0` capacity.
    - Navigate away from the page and back again.
    - Refresh the browser.
  - **Expected Result**:
    - Entered capacity values are saved correctly to Supabase `monthly_capacity` table (verify via SQL Editor: `SELECT * FROM monthly_capacity WHERE user_id = auth.uid() ORDER BY month;`).
    - Correct `user_id` associated with capacity data.
    - `month` column stored as `YYYY-MM-01` DATE type.
    - `available_days` stored as INTEGER.
    - Entered values persist after navigation and refresh, fetched from Supabase.
    - `0` capacity saves correctly.

### 2. Component & Date Handling Tests
- **Test 2.1**: CapacityManager UI - ✅ **PASSED**
  - **Action**:
    - Edit an existing capacity value for a specific month.
    - Change capacity for multiple months.
  - **Expected Result**:
    - UI updates reflect changes immediately.
    - Changes are saved to Supabase correctly (verify via SQL).
    - Date display (e.g., "May 2025") remains correct.
- **Test 2.2**: Date Edge Cases - ✅ **PASSED**
  - **Action**:
    - Verify capacity setting works correctly across year boundaries (e.g., Dec 2024 to Jan 2025).
    - Check behavior with far future dates.
  - **Expected Result**:
    - Capacity saves correctly regardless of the month/year selected.
    - No timezone-related date shifts occur.

### 3. Validation & Error Handling Tests
- **Test 3.1**: Input Validation - ✅ **PASSED**
  - **Action**:
    - Try entering a negative number (e.g., `-10`) into a capacity input.
    - Try entering non-numeric text (e.g., `abc`).
  - **Expected Result**:
    - Input validation prevents entering/saving negative numbers (allows `0`). Browser's `min="0"` should handle this.
    - Non-numeric input is rejected or ignored by the input type.
    - (Optional) Add specific JS validation if needed beyond HTML5 attributes.
- **Test 3.2**: Error Handling - ⚠️ **SKIPPED** (Considered overkill for now)
  - **Action**:
    - (Simulate if possible) Introduce a temporary network error or RLS policy failure preventing Supabase save.
    - Attempt to save a capacity change.
  - **Expected Result**:
    - A clear error message is displayed to the user (e.g., "Error saving capacity").
    - Form state is maintained if possible.

### 4. Polish & Consistency Checks
- **Test 4.1**: Console Errors
  - **Action**: Use the Capacity page, making changes.
  - **Expected Result**: No new warnings or errors appear in the browser console (check for NaN warnings).
- **Test 4.2**: Consistent UX
  - **Action**: Compare error message styles and loading indicators to those used in the Initiatives section.
  - **Expected Result**: Error handling and loading states feel consistent across different parts of the application.

### 5. (Optional) Real-time Sync Test
- **Test 5.1**: Cross-Tab Updates
  - **Action**:
    - Open Capacity page in two tabs.
    - Change a capacity value in Tab 1 and save.
  - **Expected Result**: The corresponding capacity value updates automatically in Tab 2 without a manual refresh.